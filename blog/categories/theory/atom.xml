<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: theory | Ashton Kemerling]]></title>
  <link href="http://www.ashtonkemerling.com/blog/categories/theory/atom.xml" rel="self"/>
  <link href="http://www.ashtonkemerling.com/"/>
  <updated>2018-08-11T11:42:08-07:00</updated>
  <id>http://www.ashtonkemerling.com/</id>
  <author>
    <name><![CDATA[Ashton Kemerling]]></name>
    <email><![CDATA[ashtonkemerling@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Time, Attention, and Pairing]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2013/10/26/time-attention-and-pairing/"/>
    <updated>2013-10-26T21:36:00-07:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2013/10/26/time-attention-and-pairing</id>
    <content type="html"><![CDATA[<p><a href="http://www.merlinmann.com">Merlin Mann</a> gives a great talk about Time
and Attention. The gist of his talk is that in order to create great
work, you need to balance time vs. attention. Without using your time,
you'll never create. But you must use your attention to determine if
you're creating something great. Great producers balance between these
two to both produce, and produce good work.</p>

<p>Part of my new job at <a href="http://www.pivotaltracker.com">Pivotal Tracker</a>
involves pair programming. While a lot of my programming friends express
doubt about pairing, I'm very impressed with both how productive I am
pairing, and how quickly I'm learning the code base while pairing.</p>

<p>The way that a good pair switches between who is "driving" is very
similar to Merlin's talk. The person who is typing is responsible for
producing, while the person who isn't is responsible for ensuring that
the pair is headed in the right direction. Pairs have a much easier time
finding this balance and staying on track than individual workers do.</p>

<p>It's hard to alternate between time and attention effectively when
working alone. There's no overt signal to when one is using time or
attention, making it easy to mistake "research" (reading Wikipedia) as
using your attention. As a pair this balance is much easier to achieve,
because each member is tasked with one role, and it's obvious when that
role is not being fulfilled. The non-driving member can't goof off on
Reddit or Wikipedia for the sake of "research" because it will prevent
the driving member from working. And the driving member can't slow down
too much without the other member taking over typing from them. This
helps ensure that the pair produces better code faster.</p>

<p>I'm not sure if the creators of pair programming are familiar with
Merlin's model of work, but accidentally or not they've made it much
easier for programmers to follow his advice. I'd recommend any
company to give pairing a try and see what it does for the quality and
quantity of work that their teams produce.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fast Cheap Good]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2013/06/05/fast-cheap-good/"/>
    <updated>2013-06-05T20:24:00-07:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2013/06/05/fast-cheap-good</id>
    <content type="html"><![CDATA[<p>In the distant past (1950's or so), project managers and engineers came up with what is known as the project management triangle: fast, cheap, or good; pick two.</p>

<p>While software engineering can be very different from mechanical, it does at least share the same project management setup. Quality software designed cheaply will be late, cheap software released early will be poor in quality, and quality software released on time will be expensive. These differences come from the quality and number (thus cost) of the managers and engineers, the choice of methodologies, scope of features, and internal organizational setups.</p>

<p>What is different is the fact that software engineers aren't limited by physics the way that our mechanical brethren are. With few exceptions for high performance computing, the limitation of most software projects is the imagination and effort of its engineers, not hard limits in manufacturing technologies or physics. Combine this with a fad-heavy market for programming methods (scrum! extreme! agile! pair!), and it can be very tempting to assume that we can find the perfect balance with the correct management processes and the right methodology.</p>

<p>This is false, of course. Management and methodology is about dealing with the communication overhead when enough people are working on an project. The pipe dream of management and methodology is for a group of N producers to produce N times more than one person alone. This is of course rubbish, as the <em>Mythical Man Month</em> demonstrated handily, it's simply impossible to manage or process your way to good, cheap, and fast.</p>

<p>So what's the point of it all then? Why don't we just go back to waterfall? Because the point of agile, scrum, pair programming and friends is <strong>not</strong> to get us all the way to good, cheap, and fast. The point is to go from choosing one of three, to choosing two of three. A poorly managed, low discipline team can only choose one of good, cheap, and fast; and this is of course worthless. Cheap software that's late will probably still run out of VC and be beaten by the competition. Bad and cheap software will struggle to take over the market, and software that's both bad and late probably shouldn't be written. However a well managed, well disciplined team can survey the market, measure the competition, and <em>knowingly</em> choose what compromises they wish to make in speed, quality, and cost. Poorly managed teams blunder into one of the choices, usually cheap and bad, and end up having very little control over their own fate.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learn What You Don't Like]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2012/12/10/learn-what-you-dont-like/"/>
    <updated>2012-12-10T21:19:00-08:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2012/12/10/learn-what-you-dont-like</id>
    <content type="html"><![CDATA[<p>There’s really nothing worse than someone who has lived their life surrounded by people who agree with them fully. People who live this way have confidence that precedes their knowledge, and will treat contradictory knowledge as an attack on their in-group and world view.</p>

<p>While the above mentioned effect is generally most common in religion and politics, it crops up sometimes in engineering in the so called “holy wars”. Linux vs. Mac vs. Windows, Emacs vs. Vim, etc. The more similar the items in question, the more intense the debate.</p>

<p>This is why I think it’s pretty important to try out technologies that you’d formally written off, and re-evaluate your decisions. I’ve been an Emacs user for about 5 years now, and I’d written off learning Vim for anything other than emergency config-editing on a remote server. But at the behest of my colleagues, I tried Vim for a few weeks recently, and I’ve come to a surprising conclusion: I don’t like Vim. But rather than disliking Vim because I’d already invested in Emacs, I’ve learned exactly what I need first and foremost in an editor, and an understanding of the compromises I’m making in order to use Emacs. Basically it toned me down from being a mild Emacs zealot to an Emacs user.</p>

<p>What exactly made me go back? First and foremost, I strongly prefer the way that Emacs uses buffers. The fact that I don’t have to worry about closing a buffer closing Emacs, and the fact that I can purposefully leave buffers unsaved is nice. I also like having multiple shells open to run various programs needed for development purposes, and I found the Vim solution, ConqueTerm, to be insufficient for my needs.</p>

<p>What do I miss from Vim though? While I’m not sold on modality (it’s another thing to track), Vim’s key combinations are truly superior to Emacs’ offering, especially when it comes to repeating and chaining actions. Also, while Vim’s shells are less intuitive than Emacs’, they tend to survive heavy program output better (30+ megs of terminal output to the shell tends to overload Emacs’ poor head). But the most important thing is that I learned what I value most in an editor, so I  will know in the future whether or not a new editor will be right for me.</p>

<p>Now that I look back, I see similar Emacs vs. Vim moments in the past few years. One of the more recent moments was retrying Python, which I had written off in my early college years due to a bad experience. In retrying Python, I discovered that it had a few things that I valued highly in a language, and ended up leaving Ruby for it. And I’d never have made the switch if I hadn’t tried out something I didn’t like.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hands and Feet]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2012/12/01/hands-and-feet/"/>
    <updated>2012-12-01T21:16:00-08:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2012/12/01/hands-and-feet</id>
    <content type="html"><![CDATA[<p>When I was a teenager I worked at a large amusement park in the games department, which I guess technically means I was a carnie. One of the more interesting games I worked at was the rope ladder; in order to win the game contestants had to climb up a rope ladder set at a 45 degree angle and attached to swivel points at the bottom. Unsurprisingly I learned to climb it easily (free tries and boredom does wonders for learning), but I witnessed very few winners.</p>

<p>One of the more important lessons I learned was about how to not think about specific tasks. In order to climb the ladder, you need to move opposite limbs: step forward with your right hand and left foot at the same time, etc. This spreads your weight out, and ensures that any movement you make is relatively counter-balanced, reducing the maximum amount you’ll find yourself unbalanced at a given moment. What was particularly interesting to me was the transition from not-making it, to making it. When I first started, I had to concentrate on my hands and feet, and fell constantly. Only once I learned to move my hands and feet without conscious thought, and thus free up my mind to worry about my balance, did I successfully climb the ladder.</p>

<p>This has fairly important implications to my daily work: namely that I cannot concentrate on doing good engineering work without making everything else a subconscious action. Every single non-work related activity breaks concentration for a short period of time, and potentially might take me out of the elusive “zone”. I’ve discovered that If I’m concentrating on your editor, I’m not going to code effectively (if at all). Therefore, It’s absolutely important that every single editor and environment change that you make is judged by balancing how much time/energy it takes to learn and use against its effect. The most powerful Git extension in the world for your editor will do you no good if it takes 2 minutes to commit each time: it would take less time and mindshare to simply type or alias it out on the shell.</p>

<p>For example I use the <a href="http://philjackson.github.com/magit/">Magit</a> extension for Emacs to avoid having to go to a terminal to use git; the gains for moderately complicated tasks such as stash manipulation, reverting files, and partially staging a file are truly tremendous. Similarly I use a pylint &amp; nosetests extension for Emacs to avoid having to remember the (quite long) commands it takes to run each command correctly. This also has the tremendous advantage of not linting or testing code that’s outside of my purview, thus running faster and cluttering my mind less with irrelevant results.</p>

<p>The other important take away is to not overdue it. The point of any given addition to your editing environment is to improve the quality and quantity of your engineering output. So if your editor bothers you every 5 minutes with CI notifications that aren’t related to any of your commits, you aren’t really gaining anything. This is why I ended up turning off the Pyflakes/Flymake extension to Emacs: it improved my coding a bit at the time (although most of the time it highlighted code that I hadn’t finished typing yet), but the additional .flymake files it left laying around tripled the amount of time it took for me to work with Git. It simply wasn’t worth the trouble in the long run.</p>

<p>The easiest way to tell whether or not something is worth it is to read the manual and give it a try. Some tools take a while to learn, like Magit, and others only take some time in the setup, like Flymake. Once you’ve exited the learning stage, you should think heavily about whether or not you’re concentrating on the tool instead of your work, and whether or not this has affected the quality or quantity of your output. Remember, there’s no shame in uninstalling a tool if it really doesn’t make your life easier.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reaction to Kill Your Heroes (and Comments)]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2012/11/29/reaction-to-kill-your-heroes-and-comments/"/>
    <updated>2012-11-29T00:00:00-08:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2012/11/29/reaction-to-kill-your-heroes-and-comments</id>
    <content type="html"><![CDATA[<p>Will Larsen had a nice post about what he calls <a href="http://lethain.com/doing-it-harder-and-hero-programming/">Hero Programmers</a>. Put simply, his theory is that some projects end up in a state where they count on massive effort by a select few heroes on the team. The problem is that this upsets those who aren’t heroes, burns out the heroes, and still won’t save an ailing project.</p>

<p>What was particularly interesting to me was some of the responses on Reddit. In particular one quote from “name_was_taken” stands out to me: “Fire the developers who are useless.”</p>

<p>There is a big assumption on both sides of this discussion that should be cleared. name_was_taken is assuming that the other devs aren’t carrying their own weight, Will Larsen is assuming that the environment is setup to discourage them from doing so.</p>

<p>There are obvious situations where you should fire a developer: misbehavior at work, damaging to team morale, poor performance, low reliability, etc. This is not about the obvious case. This is about when you have decent devs all around, but the distribution of effectiveness is massively unequal.</p>

<p>I think name_was_taken’s attitude comes from an assumption that there’ll be a “Star Programmer” available for this company to hire, that way they can have nothing but heroes. I don’t think that’s possible, and I think that’s a dangerous ideology to run a business on. The simple fact of it is that most programmers are average, and only a small handful are truly stellar. Therefore, any good business should attempt to hire the best, and plan for average.</p>

<p>The truly dangerous thing about the hero mentality is what it does to performance overall. Projects that require heroic attempts at fixing them often exclude team efforts. If one person is running around, massively refactoring everything, in an attempt to hold everything together, there is little to no chance that any other developer will be able to get any work done. They’ll have to keep up with a quickly changing system (that they have no input to), and make sure they don’t step on the heroes toes while working.</p>

<p>So the solution is to get out of this mode. Hero mode will burn out your heroes, and make it almost impossible to use the majority of your dev team. Even if you cull the worst members of your team, you will not be able to reliably hire more heroes in the best of circumstances, and most star programmers can smell and avoid an out of control project a mile away.</p>
]]></content>
  </entry>
  
</feed>
