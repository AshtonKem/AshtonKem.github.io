<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: theory | Ashton Kemerling]]></title>
  <link href="http://AshtonKem.github.io/blog/categories/theory/atom.xml" rel="self"/>
  <link href="http://AshtonKem.github.io/"/>
  <updated>2013-06-05T00:03:38-05:00</updated>
  <id>http://AshtonKem.github.io/</id>
  <author>
    <name><![CDATA[Ashton Kemerling]]></name>
    <email><![CDATA[ashtonkemerling@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Learn What You Don't Like]]></title>
    <link href="http://AshtonKem.github.io/blog/2012/12/10/learn-what-you-dont-like/"/>
    <updated>2012-12-10T21:19:00-06:00</updated>
    <id>http://AshtonKem.github.io/blog/2012/12/10/learn-what-you-dont-like</id>
    <content type="html"><![CDATA[<p>There’s really nothing worse than someone who has lived their life surrounded by people who agree with them fully. People who live this way have confidence that precedes their knowledge, and will treat contradictory knowledge as an attack on their in-group and world view.</p>

<p>While the above mentioned effect is generally most common in religion and politics, it crops up sometimes in engineering in the so called “holy wars”. Linux vs. Mac vs. Windows, Emacs vs. Vim, etc. The more similar the items in question, the more intense the debate.</p>

<p>This is why I think it’s pretty important to try out technologies that you’d formally written off, and re-evaluate your decisions. I’ve been an Emacs user for about 5 years now, and I’d written off learning Vim for anything other than emergency config-editing on a remote server. But at the behest of my colleagues, I tried Vim for a few weeks recently, and I’ve come to a surprising conclusion: I don’t like Vim. But rather than disliking Vim because I’d already invested in Emacs, I’ve learned exactly what I need first and foremost in an editor, and an understanding of the compromises I’m making in order to use Emacs. Basically it toned me down from being a mild Emacs zealot to an Emacs user.</p>

<p>What exactly made me go back? First and foremost, I strongly prefer the way that Emacs uses buffers. The fact that I don’t have to worry about closing a buffer closing Emacs, and the fact that I can purposefully leave buffers unsaved is nice. I also like having multiple shells open to run various programs needed for development purposes, and I found the Vim solution, ConqueTerm, to be insufficient for my needs.</p>

<p>What do I miss from Vim though? While I’m not sold on modality (it’s another thing to track), Vim’s key combinations are truly superior to Emacs’ offering, especially when it comes to repeating and chaining actions. Also, while Vim’s shells are less intuitive than Emacs’, they tend to survive heavy program output better (30+ megs of terminal output to the shell tends to overload Emacs’ poor head). But the most important thing is that I learned what I value most in an editor, so I  will know in the future whether or not a new editor will be right for me.</p>

<p>Now that I look back, I see similar Emacs vs. Vim moments in the past few years. One of the more recent moments was retrying Python, which I had written off in my early college years due to a bad experience. In retrying Python, I discovered that it had a few things that I valued highly in a language, and ended up leaving Ruby for it. And I’d never have made the switch if I hadn’t tried out something I didn’t like.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hands and Feet]]></title>
    <link href="http://AshtonKem.github.io/blog/2012/12/01/hands-and-feet/"/>
    <updated>2012-12-01T21:16:00-06:00</updated>
    <id>http://AshtonKem.github.io/blog/2012/12/01/hands-and-feet</id>
    <content type="html"><![CDATA[<p>When I was a teenager I worked at a large amusement park in the games department, which I guess technically means I was a carnie. One of the more interesting games I worked at was the rope ladder; in order to win the game contestants had to climb up a rope ladder set at a 45 degree angle and attached to swivel points at the bottom. Unsurprisingly I learned to climb it easily (free tries and boredom does wonders for learning), but I witnessed very few winners.</p>

<p>One of the more important lessons I learned was about how to not think about specific tasks. In order to climb the ladder, you need to move opposite limbs: step forward with your right hand and left foot at the same time, etc. This spreads your weight out, and ensures that any movement you make is relatively counter-balanced, reducing the maximum amount you’ll find yourself unbalanced at a given moment. What was particularly interesting to me was the transition from not-making it, to making it. When I first started, I had to concentrate on my hands and feet, and fell constantly. Only once I learned to move my hands and feet without conscious thought, and thus free up my mind to worry about my balance, did I successfully climb the ladder.</p>

<p>This has fairly important implications to my daily work: namely that I cannot concentrate on doing good engineering work without making everything else a subconscious action. Every single non-work related activity breaks concentration for a short period of time, and potentially might take me out of the elusive “zone”. I’ve discovered that If I’m concentrating on your editor, I’m not going to code effectively (if at all). Therefore, It’s absolutely important that every single editor and environment change that you make is judged by balancing how much time/energy it takes to learn and use against its effect. The most powerful Git extension in the world for your editor will do you no good if it takes 2 minutes to commit each time: it would take less time and mindshare to simply type or alias it out on the shell.</p>

<p>For example I use the <a href="http://philjackson.github.com/magit/">Magit</a> extension for Emacs to avoid having to go to a terminal to use git; the gains for moderately complicated tasks such as stash manipulation, reverting files, and partially staging a file are truly tremendous. Similarly I use a pylint &amp; nosetests extension for Emacs to avoid having to remember the (quite long) commands it takes to run each command correctly. This also has the tremendous advantage of not linting or testing code that’s outside of my purview, thus running faster and cluttering my mind less with irrelevant results.</p>

<p>The other important take away is to not overdue it. The point of any given addition to your editing environment is to improve the quality and quantity of your engineering output. So if your editor bothers you every 5 minutes with CI notifications that aren’t related to any of your commits, you aren’t really gaining anything. This is why I ended up turning off the Pyflakes/Flymake extension to Emacs: it improved my coding a bit at the time (although most of the time it highlighted code that I hadn’t finished typing yet), but the additional .flymake files it left laying around tripled the amount of time it took for me to work with Git. It simply wasn’t worth the trouble in the long run.</p>

<p>The easiest way to tell whether or not something is worth it is to read the manual and give it a try. Some tools take a while to learn, like Magit, and others only take some time in the setup, like Flymake. Once you’ve exited the learning stage, you should think heavily about whether or not you’re concentrating on the tool instead of your work, and whether or not this has affected the quality or quantity of your output. Remember, there’s no shame in uninstalling a tool if it really doesn’t make your life easier.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reaction to Kill Your Heroes (and Comments)]]></title>
    <link href="http://AshtonKem.github.io/blog/2012/11/29/reaction-to-kill-your-heroes-and-comments/"/>
    <updated>2012-11-29T00:00:00-06:00</updated>
    <id>http://AshtonKem.github.io/blog/2012/11/29/reaction-to-kill-your-heroes-and-comments</id>
    <content type="html"><![CDATA[<p>Will Larsen had a nice post about what he calls <a href="http://lethain.com/doing-it-harder-and-hero-programming/">Hero Programmers</a>. Put simply, his theory is that some projects end up in a state where they count on massive effort by a select few heroes on the team. The problem is that this upsets those who aren’t heroes, burns out the heroes, and still won’t save an ailing project.</p>

<p>What was particularly interesting to me was some of the responses on Reddit. In particular one quote from “name_was_taken” stands out to me: “Fire the developers who are useless.”</p>

<p>There is a big assumption on both sides of this discussion that should be cleared. name_was_taken is assuming that the other devs aren’t carrying their own weight, Will Larsen is assuming that the environment is setup to discourage them from doing so.</p>

<p>There are obvious situations where you should fire a developer: misbehavior at work, damaging to team morale, poor performance, low reliability, etc. This is not about the obvious case. This is about when you have decent devs all around, but the distribution of effectiveness is massively unequal.</p>

<p>I think name_was_taken’s attitude comes from an assumption that there’ll be a “Star Programmer” available for this company to hire, that way they can have nothing but heroes. I don’t think that’s possible, and I think that’s a dangerous ideology to run a business on. The simple fact of it is that most programmers are average, and only a small handful are truly stellar. Therefore, any good business should attempt to hire the best, and plan for average.</p>

<p>The truly dangerous thing about the hero mentality is what it does to performance overall. Projects that require heroic attempts at fixing them often exclude team efforts. If one person is running around, massively refactoring everything, in an attempt to hold everything together, there is little to no chance that any other developer will be able to get any work done. They’ll have to keep up with a quickly changing system (that they have no input to), and make sure they don’t step on the heroes toes while working.</p>

<p>So the solution is to get out of this mode. Hero mode will burn out your heroes, and make it almost impossible to use the majority of your dev team. Even if you cull the worst members of your team, you will not be able to reliably hire more heroes in the best of circumstances, and most star programmers can smell and avoid an out of control project a mile away.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Myth of the Lone Hacker]]></title>
    <link href="http://AshtonKem.github.io/blog/2012/11/22/the-myth-of-the-lone-hacker/"/>
    <updated>2012-11-22T20:07:00-06:00</updated>
    <id>http://AshtonKem.github.io/blog/2012/11/22/the-myth-of-the-lone-hacker</id>
    <content type="html"><![CDATA[<p>Most programmers start off their career relatively idealistic, and often marvel at the power of little used programming languages. For me, this language was Common Lisp, which I got to work with professionally. At first I believed that Lisp still had the power to revolutionize programming, but after a few years of work I realized exactly why Lisp ended up in the position it is now: community. Every programming community has a few core beliefs, both explicit and implicit, that shape the language, the libraries, and its users. The Haskell community believes that errors should be caught by the compiler as often as possible, and Ruby believes in the principle of least astonishment. The Lisp community suffers from a belief that I call the Myth of the Lone Hacker.</p>

<p>Most simply put, the myth of the lone hacker is a strong faith in the power of individual hackers to affect large scale change. Most programmers hold this belief to some degree, but the more closely held the belief, the more dangerous to the community it becomes.</p>

<p>Why is it dangerous? Because when you believe that individual hackers are the only means of affecting change, it de-incentivizes work on utilities and libraries that are necessary for group engineering efforts. Lone hackers don’t have anything to integrate, so there’s no point in working on CI utilities. Lone hackers get their work done the first time, so who needs unit tests? There’s only one machine to work on, so who needs packaging and repeatable builds? Lone hackers also know how they prefer to write their own libraries, and clearly everyone else would be better off doing as well!</p>

<p>This is largely what has happened to Lisp since the beginning of the AI Winter. Libraries tend to be single purpose “trivial” implementations that met the exact needs of the original author, and are often very difficult to extend or maintain. Documentation tends to be sparse (“read the code!” doesn’t count as documentation), in some cases resulting in a list of functions with no obvious entry points. And any attempt to learn from or copy popular languages such as Ruby, Python, and Java is dismissed as “reeking of the cubicle”.</p>

<p>Of course, what many people fail to realize is that the myth is fairly incorrect. While there may be some rare cases, the vast majority of the time brilliant hackers only start a movement. For every Donald Knuth who writes and maintains something like Tex, there are 10 or more Guido van Rossum and Linus Torvalds; highly motivated individuals who started a movement which eventually involved large numbers of engineers. Guido and Linus may be founders and public front figures of their projects, but without the effort of countless other engineers, part and full time, their projects would have never made it off the ground.</p>

<p>This is of course, nothing new. While individuals tend to have moments of insights, modern software projects are simply too large for a single individual to engineer it within a reasonable period of time. To dismiss team work as “cubicle work” is to simply dismiss the majority of potential software projects due to their scale.</p>

<p>There is some hope yet for Lisp, with tools such as QuickLisp coming along. Unfortunately I personally feel that the language has a lot of technical and social debt that’ll be difficult to overcome. What Lisp really needs to do is attract younger engineers who will eventually mature and produce good libraries for the community, and they need to do that without spoiling them with the myth in the mean time.</p>
]]></content>
  </entry>
  
</feed>
