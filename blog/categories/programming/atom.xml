<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Ashton Kemerling]]></title>
  <link href="http://AshtonKem.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://AshtonKem.github.io/"/>
  <updated>2013-06-13T21:52:30-05:00</updated>
  <id>http://AshtonKem.github.io/</id>
  <author>
    <name><![CDATA[Ashton Kemerling]]></name>
    <email><![CDATA[ashtonkemerling@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Syntactic Diabetes]]></title>
    <link href="http://AshtonKem.github.io/blog/2013/06/13/syntactic-diabetes/"/>
    <updated>2013-06-13T19:53:00-05:00</updated>
    <id>http://AshtonKem.github.io/blog/2013/06/13/syntactic-diabetes</id>
    <content type="html"><![CDATA[<p>Syntactic sugar is any feature in a programming language that aids readability without adding any features to the core language. A classic example from the Lisp languages is if vs. cond; both are capable of expressing the exact same logic, but cond is much easier to read when a large number of predicates must be checked.</p>

<p>```clojure
(if cond-a</p>

<pre><code>1
(if cond-b
    2
    (if cond-c
        3
        4)))
</code></pre>

<p>```</p>

<p>vs.</p>

<p>```clojure
(cond</p>

<pre><code>cond-a 1
cond-b 2
cond-c 3
true 4)
</code></pre>

<p>```</p>

<p>Even without knowing Clojure, it's pretty obvious what cond does: it helps flatten out deeply nested if structures into a more readable format. But syntactic sugar can hurt more than it helps when misused. Ideally they provide shortcuts to commonly used functionality, thus eliminating boilerplate. But too much sugar can be much more harmful than too little, as it can obscure intention and provide too many ways to perform the most simple tasks.</p>

<p>Syntactic Diabetes is when a language or library goes too far with the syntactic sugar. It's most easily identified when programmers ask "Why did it do that?", or have to constantly ask each other and Google what a specific trick does. Teams suffering from syntactic sugar have a hard time porting code from one developer to the next, since each will do even the most trivial of tasks differently, and will struggle to unwind intention from shortcut when changes need to be made.</p>

<p>In Python a lot of operators and system wide methods are just sugar for <em>special</em> method calls. There are quite a few of these methods, like __call__, and __getattr__. These special methods usually underlie some syntax or global method, such as Foo(a,b,c) is just a shortcut for Foo.__call__(a,b,c). __getattr__ affects attribute selection; with an object Foo, Foo.a is just sugar for getattr(Foo, "a"),  which in turn is calling __getattribute__, and __getattr__ if __getattribute__ didn't find anything. Since these are just regular object methods, it's possible to provide your own implementation for them, just like you can do with __init__.</p>

<p>This is very convenient if you need to add attributes to Foo programmatically (just implement __getattr__), or if you wish to override method attribute determination overall (implement __getattribute__). But it can make it fairly complicated to figure out if a is an actual member of Foo, or if someone just completely overrode either of the special methods.</p>

<p>The list of special Python methods goes on and on, each the underlying method for some sort of syntactic sugar. Taken individually, none of them are a bad idea. __getattr__ can help prevent an AttributeError from being raised when you want functions to act like attributes. __eq__ allows for you to provide an object specific notion of equality, and __add__ is for objects where addition makes sense. Together these don't automatically cause problems, but it does make it slightly easier to obscure the actual path of execution and cause a big sugary mess.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fast Cheap Good]]></title>
    <link href="http://AshtonKem.github.io/blog/2013/06/05/fast-cheap-good/"/>
    <updated>2013-06-05T20:24:00-05:00</updated>
    <id>http://AshtonKem.github.io/blog/2013/06/05/fast-cheap-good</id>
    <content type="html"><![CDATA[<p>In the distant past (1950's or so), project managers and engineers came up with what is known as the project management triangle: fast, cheap, or good; pick two.</p>

<p>While software engineering can be very different from mechanical, it does at least share the same project management setup. Quality software designed cheaply will be late, cheap software released early will be poor in quality, and quality software released on time will be expensive. These differences come from the quality and number (thus cost) of the managers and engineers, the choice of methodologies, scope of features, and internal organizational setups.</p>

<p>What is different is the fact that software engineers aren't limited by physics the way that our mechanical brethren are. With few exceptions for high performance computing, the limitation of most software projects is the imagination and effort of its engineers, not hard limits in manufacturing technologies or physics. Combine this with a fad-heavy market for programming methods (scrum! extreme! agile! pair!), and it can be very tempting to assume that we can find the perfect balance with the correct management processes and the right methodology.</p>

<p>This is false, of course. Management and methodology is about dealing with the communication overhead when enough people are working on an project. The pipe dream of management and methodology is for a group of N producers to produce N times more than one person alone. This is of course rubbish, as the <em>Mythical Man Month</em> demonstrated handily, it's simply impossible to manage or process your way to good, cheap, and fast.</p>

<p>So what's the point of it all then? Why don't we just go back to waterfall? Because the point of agile, scrum, pair programming and friends is <strong>not</strong> to get us all the way to good, cheap, and fast. The point is to go from choosing one of three, to choosing two of three. A poorly managed, low discipline team can only choose one of good, cheap, and fast; and this is of course worthless. Cheap software that's late will probably still run out of VC and be beaten by the competition. Bad and cheap software will struggle to take over the market, and software that's both bad and late probably shouldn't be written. However a well managed, well disciplined team can survey the market, measure the competition, and <em>knowingly</em> choose what compromises they wish to make in speed, quality, and cost. Poorly managed teams blunder into one of the choices, usually cheap and bad, and end up having very little control over their own fate.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing Butler.el]]></title>
    <link href="http://AshtonKem.github.io/blog/2013/05/03/introducing-butler-dot-el/"/>
    <updated>2013-05-03T20:00:00-05:00</updated>
    <id>http://AshtonKem.github.io/blog/2013/05/03/introducing-butler-dot-el</id>
    <content type="html"><![CDATA[<p>I'm a big fan of reducing barriers to increase adoption and compliance. One of the largest examples for me in the past few months was when I tried out Eclipse for Python Development. The most important plugins for me (other than Python and Git) were the Jenkins and Jira plugins. Quick access to my tasks and instantaneous in-editor feedback about job status increased the likelihood that I would respond to failed builds or fill out tickets correctly.</p>

<p>I eventually decided that Eclipse was overkill for Python development, and way too heavy for a Macbook Air. But in my switch back to Emacs I particularly missed my Jira and Jenkins plugins. This is why I'm writing to announce the 0.1.0 release of <a href="https://github.com/AshtonKem/Butler">Butler</a>. Butler allows for you to view the jobs on your Jenkins servers, and trigger new jobs without switching out of Emacs.</p>

<p>At this point Butler's feature set is modest: view, refresh, and trigger. These are just the groundwork functions for a larger feature set in the coming weeks, including console output, visual indication of running jobs, watching jobs, build queue, etc. I have high hopes that in a few months this plugin will be as mature as its eclipse counterpart.</p>

<p>If you have any bugs or feature requests, please add them to the Github issue tracker.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Binding vs. Assignment ]]></title>
    <link href="http://AshtonKem.github.io/blog/2013/04/30/binding-vs-assignment/"/>
    <updated>2013-04-30T07:23:00-05:00</updated>
    <id>http://AshtonKem.github.io/blog/2013/04/30/binding-vs-assignment</id>
    <content type="html"><![CDATA[<p>A coworker of mine was recently running into problems with the following snippet of Python code, and turned to another functionally oriented developer and myself for help.</p>

<p>``` python Odd Functions
funs = []
for i in ["a" "b"]:</p>

<pre><code>def internal_function():
    return i
funs.append(internal_function)
</code></pre>

<p>print funs<a href="">0</a>
print funs<a href="">1</a>
```</p>

<p>At first glance, one would expect this to print "a" then "b". But much to my surprise (and my coworkers frustration), it was returning "b" both times.</p>

<p>My first instinct was that Python was closing properly, but was messing up the namespacing. So I asked him to use lambdas instead, creating this:</p>

<p>``` python Lambdas
funs = []
for i in ["a", "b"]:</p>

<pre><code>funs.append(lambda : i)
</code></pre>

<p>print funs<a href="">0</a>
print funs<a href="">1</a>
```</p>

<p>Same result! So by this point we know that its not namespacing that is causing the problems, as you can't accidentally assign two lambdas the same name. So I began to suspect that the use of "i" was the issue. Perhaps we're closing around i, which is a mutable variable, and Python can't anticipate that we want a copy instead of the actual reference. Since i is mutable, both closures are having what i means changed from underneath them after closure creation time. (Coincidentally, Python 2.7.3 keeps i around even after the loop is completed, which I think is odd).</p>

<p>So the solution here would be to use a temporary variable. Any variable first created inside a loop should theoretically only have a lifespan of one iteration through the loop. So let's try the following:</p>

<p>``` python Temporary Variables
funs = []
for i in ["a", "b"]:</p>

<pre><code>temp = i
funs.append(lambda : temp)
</code></pre>

<p>print funs<a href="">0</a>
print funs<a href="">1</a>
```</p>

<p>Same result, again! So clearly python is mishandling variables by a large amount. So what's going on here? My fellow functional coworker was finally able to explain: the real problem here is that Python conflates binding and assignment. Binding is used to create a new variable <em>within the current context</em>, while assignment can only change the value of a given variable within the narrowest bound scope.</p>

<p>Why is this an issue? Well, Python uses the same symbol "=", to specify binding and assignment, while most other languages use two syntactic rules. For example Go apparently uses ":=" to bind, and "=" to assign. Java uses type declarations to denote bindings, and Clojure/Haskell more or less only have bindings underneath. Unfortunately there's an upper limit to how intelligent an imperative compiler can get, especially in interpreted languages where the compiler must be fairly quick. So Python doesn't do the leg work to realize that temp is only used inside the loop, and binds it only once <em>outside the loop</em>. The side effect of this is that anyone who closes over any local variable inside the loop will be surprised when it is mutated by further iterations, and said variables will be left laying around <strong>after the loop is done</strong>.</p>

<p>So how do we get out of this? One obvious option is to pick a language that understands the difference. Short of that, use a separate function to force Python's hand.</p>

<p>``` python Ugly Fix
def create_lambda(x):</p>

<pre><code>return lambda : x
</code></pre>

<p>funs = []
for i in ["a", "b"]:</p>

<pre><code>funs.append(create_lambda(i))
</code></pre>

<p>funs<a href="">0</a>
funs<a href="">1</a>
```</p>

<p>Which unfortunately is pretty ugly. Other languages will get you out of this bind though. Clojure has no concept of assigning variables, only binding. So the only way to create mutable state in Clojure is through successive binds, or via the special Software Transactional Memory functions, which are specially designed for concurrency.</p>

<p>``` clojure Nice and Clean
(def funs</p>

<pre><code> (for [i ["a" "b"]]
     (fn []
         i)))
</code></pre>

<p>(println ((first funs)))
(println ((second funs))
```</p>

<p>And according to my Go enthused coworker, this also works:</p>

<p>``` go</p>

<p>func main() {</p>

<pre><code>for i:=0; i&lt;4; i++ {
    tmp := i

    funs[i] = func () int {
        return tmp

        }
}
fmt.Println(funs[0]())
fmt.Println(funs[1]())
fmt.Println(funs[2]())
</code></pre>

<p>}
```</p>

<p>If you are currently working on a Python project, or are a Python enthusiast, the only hope is to be careful, and hope that Python 3's compiler might be more intelligent.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Size Matters]]></title>
    <link href="http://AshtonKem.github.io/blog/2013/04/23/size-matters/"/>
    <updated>2013-04-23T21:54:00-05:00</updated>
    <id>http://AshtonKem.github.io/blog/2013/04/23/size-matters</id>
    <content type="html"><![CDATA[<p>About 6 months ago I started to look for a new language for hobby projects. I wanted something practical, yet fun. I managed to limit the criteria down to:</p>

<ul>
<li>Functional</li>
<li>Good community</li>
<li>Growing acceptance</li>
</ul>


<p>This automatically eliminates a lot common languages, like Python, Ruby, and Java. After my Common Lisp job, I knew that a sane compilation system/target were an absolute must, so I looked at Scala first. On the surface Scala seemed a real winner: growing fan base, increasing commercial adoption, functional, and targeting the JVM. But while trying out Scala I realized that I had missed a huge criteria: language size.</p>

<p>There's only so much information that a programmer can keep in their mind at a time. Every programmer needs to split their internal memory in at least 4 different ways, if not more. There are language details to remember, library or API interfaces to recall, domain knowledge to retain, and possibly coordination or social issues to be concerned about. Once this internal memory is exceeded details end up being forgotten, and recalling forgotten information involves an expensive round trip to documentation, code, or the internet.</p>

<p>There's no escaping the need to recall language details, at least until someone invents a syntax free programming languages; similarly it's near impossible to write an application of any size without relying on libraries or APIs. Domain knowledge is often expensive to acquire and beneficial to have. And social issues cannot be resolved by programming language choice alone.</p>

<p>So the real question is, what are you going to skimp on? Are you going to pay the price of memory "cache misses"? Are you going to forget portions of your language, or certain libraries? Or are you going to segregate domain knowledge among the team so that everyone knows their bit only?</p>

<p>The real world answer is probably a bit of each. But I contend that reduction of language features in memory is the least damaging of all the outcomes. I doubt it's controversial to say that domain knowledge should be shared widely among developers, and should be as much in memory as possible; programmers who understand what they're programming for tend to program better on average. Similarly it's hard to eliminate a decently written library: that functionality has to come from somewhere, and it'll either be an external library, an internal one, or duplicated code.</p>

<p>But language reduction is an interesting idea. Programmers long ago got away with previous few features, yet managed some amazing things. Don't believe me? Consider how small the Scheme spec is compared to say, Java. It reduces the need for fancy and hard to learn IDEs, allows the programmer to get more done between looking up function or class definitions, and increases the speed with which an engineer can fully understand a piece of code.</p>

<p>It was actually this feature that finally drove me away from Scala to Clojure. After a few hours of Scala work I was turned off by the size of the language, and got tired of saying "Why did it do that?" Clojure on the other hand is relatively small, only a dozen "special forms" which have to be hard coded into the language, and then a 3-4 dozen core functions. This means that I can both keep the entire language in memory, and retain a large amount of library and domain knowledge to get work done.</p>
]]></content>
  </entry>
  
</feed>
