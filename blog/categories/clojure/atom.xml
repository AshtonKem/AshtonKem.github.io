<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | Ashton Kemerling]]></title>
  <link href="http://www.ashtonkemerling.com/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://www.ashtonkemerling.com/"/>
  <updated>2018-02-21T18:28:58-08:00</updated>
  <id>http://www.ashtonkemerling.com/</id>
  <author>
    <name><![CDATA[Ashton Kemerling]]></name>
    <email><![CDATA[ashtonkemerling@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java Without If]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2017/01/26/java-without-if/"/>
    <updated>2017-01-26T19:54:00-08:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2017/01/26/java-without-if</id>
    <content type="html"><![CDATA[<p>Over the past year my team has been doing something shocking to a lot of
engineers: we're favoring pure Java over Clojure. We aren't rewriting all our
Clojure code, but we definitely prefer Java for green field projects.</p>

<p>This post is not going to be a compare and contrast between the two, nor am I
going to bash Clojure. Language compare and contrast posts always descend into
flame wars, and it's very easy to confuse the result of hard lessons learned
with the benefits of a new language.</p>

<p>Instead I'd like to highlight a very strange aspect of our new Java development,
and I hope that you're sitting down for this. Except tests, I have fewer than a
dozen <code>if</code> statements currently committed in our Java codebase.</p>

<p>It would be easy to assume that we're just using Java's method dispatch to
replace if statements; rather than inspecting data and calling if/else on it,
you can use interfaces and count on the implementation to provide the difference
in behavior. But such an explanation is insufficient: objects don't magically
construct themselves from unstructured data, and Clojure is not without its own
dynamic dispatch <a href="https://clojure.org/reference/multimethods">facilities</a>.</p>

<p>Ultimately the real explanation for this strange code design lies in my
colleague's extremely exceptional <a href="https://github.com/palatable/lambda">Lambda</a>
library. It contains a lot of things that a Haskell/Scala developer would
recognize such as Either types, function utilities, coproducts, etc. etc.</p>

<p>In particular I'd like to draw your eye to the Either type, which has replaced
the vast majority of our explicit <code>if</code> calls. Either is the logical
successor to the Java
8 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">Optional</a>
type. Optional represents the presence of a value of type <code>T</code> with
 <code>Optional::of</code>, or it's absence with <code>Optional::empty</code>. Either on the
other hand is parameterized to two values, L and R, and represents the presence
of either a value of type L, <em>or</em> a value of type R.</p>

<p>Why is this a logical extension of <code>Optional</code>? Because while Optional is
used to represent a result that may have no value (replacing a null), Either is
used to represent a result that might have been a failure, replacing a thrown
exception, with convention being that left side values represent failure and
right side values representing success.</p>

<p>So, what does that buy us? Well, consider what Optional gets us in the following code snippets.</p>

<p>```java</p>

<p>String x = Helper.functionOne();
if (x != null) {
  x = Helper.functionTwo(x);
  x = Helper.functionThree(x);
  if (x != null) {</p>

<pre><code>...
</code></pre>

<p>  }
}
```</p>

<p>```java
Optional<String> x = Helper.functionOne()</p>

<pre><code>                       .map(Helper::functionTwo)
                       .flatMap(Helper::functionThree);
</code></pre>

<p>```</p>

<p>Optional gives us the ability to say "if a value exists, apply this function to
it" repeatedly. It also gives us the ability to chain successive calls that
return Optionals together with the <code>flatMap</code> function, eliminating the need
for unsightly and error prone manual null checks. It's also safe for <code>map</code>
and <code>flatMap</code> to go from <code>Optional&lt;A&gt;</code> to <code>Optional&lt;B&gt;</code>, which might
eliminate the need for intermediate variables in your code.</p>

<p>Either give us much of the same, but with the ability to represent <strong>why</strong> the
computation failed with left values, along with the ability to chain together
functions working on an Either type. All of the greatest hits of functional
programming are provided for Either, including <code>map</code>, <code>flatMap</code>, and <code>filter</code>.</p>

<p>As a concrete example, imagine a hypothetical JSON parsing library. Parsing is
tricky business, you're all but guaranteed that a failure will happen at
runtime. So how do you handle it? Previously you had 4 choices.</p>

<ul>
<li>return null</li>
<li>return Optional&lt;ParsedType></li>
<li>checked exception</li>
<li>unchecked exception</li>
</ul>


<p>Null is obviously bad, and unchecked exceptions are also risky. Checked
exceptions guarantee that someone will deal with the issue, but they are
extremely annoying, and might result in disparate and different exception
handlers all over the place. Optional is nice, it's safer than null and marks in
the type signature that failure is an option, but it's a bit lacking on
explaining <strong>why</strong> a failure occurred.</p>

<p>What if instead this library returned <code>Either&lt;Exception, JsonNode&gt;</code>, or even
 <code>Either&lt;Set&lt;String&gt;, JsonNode&gt;</code>? The potential for failure is in the type
signature again, we don't need a try/catch, but if we want the unwrapped
JsonNode we have to deal with the potential for a left value. And any functions
we have that operate only on JsonNode can be passed in using the <code>map</code>
function, making chaining a breeze.</p>

<p>Better still we can write other functions that might fail in this form, such as
JSON validation, so that we can chain them together using <code>flatMap</code>. If the
json parsing has failed, flatMap does nothing (it only works on right values),
replacing the need for successive null checks, nested try/catch blocks, or
complicated state checking during exception handling to return the correct
value.</p>

<p>As a result of all this, you can easily imagine a JSON API endpoint looking
something like this:</p>

<p>``` java
public HttpResponse handle(HttpRequest request) {</p>

<pre><code>return JsonParser.parse(request.getBody())
                 .flatMap(Validator::validate)
                 .map(ServiceObject::businessLogic)
                 .flatMap(JsonGenerator::generate)
                 .match(l -&gt; HttpResponse.internalServerError(l.getMessage()),
                        r -&gt; HttpResponse.ok(l));
</code></pre>

<p>}
```</p>

<p>All the potential failure cases are covered by returning an Either rather than
throwing an exception. The very last step is <code>match</code>, which takes two
functions to unify a potential left or right value to the exact same type, which
in this case is <code>HttpResponse</code>.</p>

<h3>What does this get me?</h3>

<p>Well, first off I think it's beautiful. I know that's a subjective call, but the
data flowing neatly from top to bottom without huge nesting if cases and early
return values is very aesthetically pleasing to me.</p>

<p>More functionally it's easier to refactor with the help of the compiler. If I
want to add different return status codes to match different scenarios, the
compiler helps me out a lot more than if I'm adding an extra return case. If I
convert the left side to a HttpResponse early, the compiler will helpfully
remind me that the later flatMap calls cannot change <code>Either&lt;HttpResponse,
JsonNode&gt;</code> to <code>Either&lt;Exception, BusinessObject&gt;</code>. Such changes are easily
fixed once the compiler has pointed it out, but extremely hard to find on your
own.</p>

<p>But most fundamentally is that we've encoded our code's states in the type
system, not variable states. The potential for JSON parsing to fail is encoded
in its type, not in the potential for a variable to null, or false, or for an
exception to have been thrown. You're leaning on the compiler to tell you if
you've handled the failure cases properly, as the code won't compile otherwise.
Now instead of testing for runtime exceptions you only test to make sure that
your business logic is correct.</p>

<p>If you've ever been interested in what the Haskell or Scala developers have been
talking about with functional type safety, I'd highly recommend taking a look at
Lambda to get a taste of it in Java.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Increasing Frustration With Clojure]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2016/06/11/my-increasing-frustration-with-clojure/"/>
    <updated>2016-06-11T06:24:00-07:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2016/06/11/my-increasing-frustration-with-clojure</id>
    <content type="html"><![CDATA[<p><strong>Edit: TL;DR: This is about how bugs in Clojure are handled by the Clojure Team, not just complaints about specific bugs I've seen.</strong></p>

<p>First off, this is not a "I'm quiting in disgust" post. Those are childish and a waste of everyone's time. But this is a post of frustration as I watch something I really like being slowly allowed to get worse.</p>

<p>First off, some history. My first job out of College was in Common Lisp, and I love/hated it. The power it brought and the pain it brought were both one and the same. No modern libraries, no modern build tools (this was before <a href="https://www.quicklisp.org/beta/">QuickLisp</a>). One on hand, I <em>loved</em> working with paredit and Emacs, being able to quickly fly about my code and manipulate it in blocks rather than line by line. On the other, I couldn't help but be envious of those who could actually ask for help from a functioning open source community.</p>

<p>A few years of Python, Ruby, and Javascript later, I found Clojure. And I thought I'd found the solution to literally all of the things. Paredit works again? Check. A thriving open source community? You got it. Deploy as a Jar rather than CL's hilarious "dump the state of a running program and call it good" setup? Fuck. Yes.</p>

<p>And beyond the superficial things, there was a lot to love, especially coming from a more recent brush with Ruby on Rails. Clojure makes it very easy to make things <a href="https://en.wikipedia.org/wiki/Referential_transparency">referentially transparent</a>, and it tends to favor explicit calling semantics over convention (or more derisively, "magic"). This means that a Clojure code base will require more plumbing code, but that also means it's possible to navigate to the code that does routing and understand how it works, no more having to search through your framework's codebase just because they do dynamic method creation and method_missing magic.</p>

<p> As far as I was concerned, the editor was the only weak point for Clojure. Back when I got into Clojure Cursive was still brand new, Emacs really was the only editor that was worth using and even it had some stability and usability issues. But I assumed that continued interest would stabilize Emacs, bring Vim up to speed, and improve Cursive to the point where it would be competitive with Emacs/Vim.</p>

<p> But all was not well, and if I'd paid attention I might have noticed a few places where the core Clojure's teams priorities didn't seem to make much sense to me. And now that I work in Clojure professionally, I really cannot ignore them or remain silent about them any more.</p>

<p> The core Clojure team prefers green field development over improvements and bug fixes to existing code to a degree that deeply worries me. I no longer trust that any issues I find stand a chance of getting fixed, as all the bugs we've posted are either in limbo, or flat out rejected. Multiple members of my team have given up on posting new bugs because they have no faith that it'll help anyone.</p>

<p> These are pretty heavy and vague accusations, so I'm gonna break this down a bit to make it clearer and easier to digest.</p>

<h2>Ignorance or Apathy of Underlying Principles</h2>

<p> Programming isn't math per-se, especially in a language that's not explicitly based on Category or Type theory. That said a lot of the things that we do are backed or defined by mathematics, and to ignore that is to guarantee bugs. This is most clear in clojure.set which contains functions that are supposed to mirror the definitions created by Set Theory like <code>union</code>, <code>difference</code>, <code>intersection</code>, etc.</p>

<p> And the namespace is completely riddled with bugs. <code>union</code> returns duplicates if some of the inputs are lists instead of sets <em>depending on their length</em>. <code>intersection</code> will either return nonsense values or throw a ClassCastException if you provide it anything other than sets, again dependent on data.</p>

<p>On their own, this is no big deal. Bugs happen, there's really no point in berating people just because they made a mistake. Instead the bug gets fixed as best and as soon as reality allows and we all move on. In fact, for the above bugs there are two possible fixes: raise an IllegalArgumentException if anything other than sets are provided, or coerce lists and vectors to sets before continuing. Both of these approaches are valid due to the fact that this is a dynamic language that defaults to immutable collection semantics; which one you pick is then a matter of how you want to affect your downstream users.</p>

<p>Oh wait, some of these bugs were filed in <em>2009</em>, 7 fucking years ago! Here comes the berating. These functions are <strong>tiny</strong>, a simple implementation of <code>union</code> is one line. And while they're heavily used, they're simple in usage and signature; no need to change a lot of call sites to fix this bug. There are only two reasons to explain why these bugs have not been fix; they either do not understand that this is an issue, or they do not care.</p>

<p>Actually, their comments on the issues lets us know that they do not understand that this is an issue. Rich Hickey said in 2009 "the fact that these functions happen to work when the second argument is not a set is an implementation artifact and not a promise of the interface". How you define getting the wrong type with nonsense values counts as "working" is beyond me. Is it just because it doesn't throw an Exception? Anyone here prefer bad data instead of exceptions when dealing with functions like this? I doubt it.</p>

<h2>Inconsistency Between Best Practices and Clojure Implementation</h2>

<p>Clojure includes a pretty powerful concept called protocols. Basically a protocol is an interface that can be added to classes after the fact, and lets you dispatch to different behavior silently at run time.</p>

<p>This is pretty neat, it lets you abstract over multiple data types and include Java classes in the fun. For example ISeq provides all the methods needed to iterate over a collection and it works with all the Clojure and Java data types. So you can use Clojure's <code>map</code> function over its own data types and Java's because it depends on the seq interface.</p>

<p>As you can imagine, this is the recommended way to work with things. Rather than having to do <code>cond</code> or <code>if</code> logic on various classes, define and use an appropriate protocol and you're good to go!</p>

<p>It sounds like a good theory doesn't it? But Clojure itself doesn't actually do this. Clojure.core contains 89 calls to <code>instance?</code> in order to check runtime type, instead of the helper methods to check for protocol implementation.</p>

<p><a href="http://dev.clojure.org/jira/browse/CLJ-1944">Here</a> is a bug found by my colleague that highlights this issue. List and Vector are both seqs, but <code>into</code> for a map only accepts vectors, lists causes a ClassCastException. This is kind of nuts because an IllegalArgumentException makes more sense, and there's no practical reason to differentiate between a list of two elements and a vector of two elements. Actually, Clojure considers <code>[1 2]</code> and <code>(list 1 2)</code> to be equal, so this really makes no sense</p>

<p>Even more obnoxious, it was closed as wontfix. Apparently a single sentence in the docs is good enough for the Clojure team, as well as a paper-thin argument about performance on a 2 element list. So not only is this just broken in a barely documented and very surprising way, Clojure itself ends up programmed in a way that isn't recommended by the Clojure docs.</p>

<p>This has spread to other projects. <a href="https://github.com/omcljs/om">Om</a> has a bug where lists aren't acceptable in its data structures, only maps sets and vectors. To say that I was treated pretty <a href="https://github.com/omcljs/om/issues/246">shabbily</a> by David Nolen on this issue almost goes without saying. Naturally the intro <a href="https://github.com/omcljs/om/wiki/Basic-Tutorial">docs</a> barely call this out, and the docs <a href="https://github.com/omcljs/om/wiki/Cursors">dedicated</a> to the troubled component does not mention this at all. To be fair, the <a href="https://github.com/omcljs/om/wiki/Troubleshooting">troubleshooting guide</a> explains this, but in my opinion that's probably a clue that the bug is common enough that you should find a fix for it.</p>

<h2>Show Stopping Bugs Remain Untouched</h2>

<p>There are a shocking number of big, bad bugs hiding in the Clojure Jira, some really old</p>

<ul>
<li><a href="http://dev.clojure.org/jira/browse/CLJ-308">This one</a> about fixing with-open for Clojure defined stuff provided a patch 5 years ago.</li>
<li><a href="http://dev.clojure.org/jira/browse/CLJ-440">Calling VarArgs Successfully</a> from 6 years ago.</li>
<li><a href="http://dev.clojure.org/jira/browse/CLJ-700">Contains? broken for transient collections</a> from 5 years ago. But it's due for this version, so cross your fingers!</li>
<li><a href="http://dev.clojure.org/jira/browse/CLJ-1463">Bizarrely Defensive Response</a> for a minor code review.</li>
<li><a href="http://dev.clojure.org/jira/browse/CLJ-1741">Duelling ClassLoaders</a> first discovered last year. This one breaks our editors constantly. Not even assigned.</li>
</ul>


<p>I could go on, but I feel that I've made my point. Bugs, even major ones are either closed as "wontfix", or are ignored for years despite the pain felt by users. That's not even covering the dismissive and distrustful attitude given in some of the replies.</p>

<h2>Strange Priorities</h2>

<p>The Clojure team appears to be super focused on new features, at the exclusion of existing namespaces. The big highlights from the past year or so have been Transit, Transducers, and Spec.</p>

<p>These are okay, I guess. We use transit a bit, and it's kinda cool. But we really don't use 90% of its features, it's basically JSON for us that can convert numbers to BigDecimals.</p>

<p>We have yet to find a place that Transducers would help us. They're neat enough, but the built in lazy sequences are working A-OK for us, so we don't really feel the need to change over.</p>

<p>I'm not holding my breath for Spec. It doesn't fix anything for me that other libraries aren't already providing.</p>

<p>Know what hasn't seen any major improvements in forever? Clojure.test. Clojure.Test is frankly sad. Fixtures are done via some global state, and you can't even setup fixtures to work across the entire test suite. Need a database to run functional tests? Well either you need to override the main test runner (good luck running individual tests now!) or you have to setup each namespace to open and close its own database connection (don't forget, or your DBA will wonder why Emacs has 1000+ database connections). I'm 100% behind the idea that I'll have to write a bit of glue code, but without anywhere to <em>put</em> that code I'm kind of screwed.</p>

<p>And then there is the <code>is</code> function. It's literally the only assertion provided by clojure.test. It's this fancy little macro that grabs its body, evaluates it, then uses the body to produce a human readable message about the failure.</p>

<p>And it's garbage. The fact that <a href="https://github.com/pjstadig/humane-test-output">plugins</a> exist to make this easier on the eyes should tell you everything you need to know. Oh but don't use that with Emacs/Cider! It'll crash the Cider plugin, which is trying to parse the default output.</p>

<p>Back when I used Emacs, I had a stash on my box that disabled AOT, pedantic checking, and the humane-test-output plugin from my project.clj in order to use Cider. Without that stash applied Cider wouldn't start, couldn't reload code, and would crash when running tests. Now that I use Cursive that's less of an issue, but it's still kind of nuts I had to decide between a working editor and readable output when I ran <code>lein test</code></p>

<p>Sorry, I didn't even highlight the craziest bit of that last paragraph, did you catch it? I had to disable humane-test-output from my <em>project.clj</em>. That's because you install it by injecting some code in project.clj that <strong>redefines</strong> some multi-methods, because there's no plugin architecture. How nuts is that?</p>

<p>Now I might hear you say "You don't have to use clojure.test!", and you're right. But clojure.test has clearly won in the Clojure testing namespace. The only real competitors for clojure.test are <a href="https://github.com/slagyr/speclj">Speclj</a> and <a href="https://github.com/marick/Midje">Midje</a>. I've literally never met someone in person that's used Speclj, and Midje is super polarizing because it's basically a collection of magic macros. The fact that the second entry for Midje is about CircleCI rewriting from Midje to clojure.test should tell you a lot.</p>

<p>So why don't we have more creature comforts for clojure.test? I'm not really sure. As far as I can tell the change to it was the inclusion of <a href="https://github.com/clojure/test.check">test.check</a>, but that really was nothing more than simple-check getting renamed and transferred to Clojure ownership.</p>

<h1>Okay, Now What?</h1>

<p>As I stated before, this isn't a "I'm quitting Clojure!" post. Partly this is because I work in Clojure on a daily basis, and I both like my job and am professional enough to keep working despite my complaints. And partly this is because I do not have a replacement for Clojure in mind for my own personal projects. But off the top of my head, there are the things I'd like to see fixed in the Clojure areas.</p>

<ul>
<li>More love for clojure.test.</li>
<li>No tolerance for bugs that result in bad-data. Built in functions should either work, or throw an understandable exception.</li>
<li>Friendlier responses in Jira. Someone who has gone to the work to sign up and try to help out should be treated with more respect.</li>
<li>Fix underlying compiler bugs before adding features. The other way only codifies bad behavior and guarantees that it cannot be fixed.</li>
<li>Understand that if enough people have the same issue, it's the codes fault and a FAQ entry is <strong>not</strong> good enough.</li>
</ul>


<p>Basically I want Clojure to be a simple to use language backed by a friendly and active community. What I see now is drifting in the wrong direction, and I'd like to see that corrected.</p>
]]></content>
  </entry>
  
</feed>
