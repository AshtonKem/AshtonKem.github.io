<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Ashton Kemerling]]></title>
  <link href="http://www.ashtonkemerling.com/atom.xml" rel="self"/>
  <link href="http://www.ashtonkemerling.com/"/>
  <updated>2013-10-23T22:00:52-06:00</updated>
  <id>http://www.ashtonkemerling.com/</id>
  <author>
    <name><![CDATA[Ashton Kemerling]]></name>
    <email><![CDATA[ashtonkemerling@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Dangers of Partisanship]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2013/07/15/the-dangers-of-partisanship/"/>
    <updated>2013-07-15T21:01:00-06:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2013/07/15/the-dangers-of-partisanship</id>
    <content type="html"><![CDATA[<p>Anyone who knows me personally knows that I am a huge Clojure fan. I could go on and on about why it&#8217;s the best; the regularity, the macros, ClojureScript, core.logic, etc. etc.</p>

<p>But last week I attended <a href="http://lambdajam.com">LambdaJam</a>, which was awesome by the way, and I came back with a different opinion. No, I don&#8217;t think Haskell or Erlang tops out Clojure, I&#8217;m still probably going to reach for Leiningen for all my personal projects. But I learned that it&#8217;s a good idea to keep an eye on other languages, since no language will ever be so good that you never need to touch anything else.</p>

<p>In particular I learned the joy of the APL based languages, especially J. I learned that the F# people have a novel way of dealing with statically typing external resources via type providers, and I learned that Haskell can indeed be tight and clean despite what all those monad tutorials imply. I will probably take each of these subjects apart in separate posts in the future, I&#8217;m still trying to pick up bits and pieces of my thoughts after several intense key notes overloaded my brain.</p>

<p>What&#8217;s the take away? That functional languages are a lot more diverse than most OOP/procedural languages, and that there&#8217;s a lot that can be learned from them. So instead of picking your favorite and only learning that, you really should try to learn several to cover your bases.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stealing Terminology]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2013/07/02/stealing-terminology/"/>
    <updated>2013-07-02T22:37:00-06:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2013/07/02/stealing-terminology</id>
    <content type="html"><![CDATA[<p>One of my favorite tricks is to borrow terminology from other walks in life. This is particularly important for me, since it&#8217;s all too easy for engineers to end up living and talking in pure engineering speak. Looking to other careers for the correct words to describe something allows one to express ideas that might not be easily communicated otherwise.</p>

<p>If you look carefully, you can see examples of this in engineering blog posts. People talk about fighting entropy, or the metaphysics of data. These are terms that did not originally have any engineering context whatsoever, being brought in to express ideas and concepts about another subject.</p>

<p>My most recent borrowed term is <em>Force Multiplier</em>. A force multiplier is anything that allows an group or individual to be more effective without an increase in effort. It&#8217;s normally a military term referencing how better weather forecasts, equipment, or intelligence can allow a unit to accomplish much more without increasing effort/losses. I like to use it in reference to things like unit tests and automation, that make me more effective as an engineer without costing me more time. If I don&#8217;t have to babysit a build waiting to type in the next step, then I can get back to work while a CI server works for me. I&#8217;m instantly more effective without actually spending more time at work. With a comprehensive suite of unit tests I can spend less time worrying and validating that my refactoring has damaged the quality of the system, thus I can get more work done in the same period of time.</p>

<p>I&#8217;m sure there are far more examples of this than I&#8217;ve listed, but they&#8217;re always fun to find and analyze.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fast Cheap Good]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2013/06/05/fast-cheap-good/"/>
    <updated>2013-06-05T20:24:00-06:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2013/06/05/fast-cheap-good</id>
    <content type="html"><![CDATA[<p>In the distant past (1950&#8217;s or so), project managers and engineers came up with what is known as the project management triangle: fast, cheap, or good; pick two.</p>

<p>While software engineering can be very different from mechanical, it does at least share the same project management setup. Quality software designed cheaply will be late, cheap software released early will be poor in quality, and quality software released on time will be expensive. These differences come from the quality and number (thus cost) of the managers and engineers, the choice of methodologies, scope of features, and internal organizational setups.</p>

<p>What is different is the fact that software engineers aren&#8217;t limited by physics the way that our mechanical brethren are. With few exceptions for high performance computing, the limitation of most software projects is the imagination and effort of its engineers, not hard limits in manufacturing technologies or physics. Combine this with a fad-heavy market for programming methods (scrum! extreme! agile! pair!), and it can be very tempting to assume that we can find the perfect balance with the correct management processes and the right methodology.</p>

<p>This is false, of course. Management and methodology is about dealing with the communication overhead when enough people are working on an project. The pipe dream of management and methodology is for a group of N producers to produce N times more than one person alone. This is of course rubbish, as the <em>Mythical Man Month</em> demonstrated handily, it&#8217;s simply impossible to manage or process your way to good, cheap, and fast.</p>

<p>So what&#8217;s the point of it all then? Why don&#8217;t we just go back to waterfall? Because the point of agile, scrum, pair programming and friends is <strong>not</strong> to get us all the way to good, cheap, and fast. The point is to go from choosing one of three, to choosing two of three. A poorly managed, low discipline team can only choose one of good, cheap, and fast; and this is of course worthless. Cheap software that&#8217;s late will probably still run out of VC and be beaten by the competition. Bad and cheap software will struggle to take over the market, and software that&#8217;s both bad and late probably shouldn&#8217;t be written. However a well managed, well disciplined team can survey the market, measure the competition, and <em>knowingly</em> choose what compromises they wish to make in speed, quality, and cost. Poorly managed teams blunder into one of the choices, usually cheap and bad, and end up having very little control over their own fate.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stop Surprising Me Ubuntu]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2013/06/04/stop-surprising-me-ubuntu/"/>
    <updated>2013-06-04T23:19:00-06:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2013/06/04/stop-surprising-me-ubuntu</id>
    <content type="html"><![CDATA[<p>There are almost as many design principles as there are articles about them. But my two favorites are the Principle of Least Surprise, and You Ain&#8217;t Gonna Need It.</p>

<p>The Principle of Least Surprise, is one of the design principles of the language Ruby, specifically in the context of &#8220;the principle of least surprise after you learn Ruby very well.&#8221; And all good systems have the property that they do not surprise experienced users, but great systems do not even surprise inexperienced users. This is what Apple has been doing for years, trying to make their products mimic familiar scenarios and objects from the real world, so that users can simply pick up the product and use it.</p>

<p>You Ain&#8217;t Gonna Need It is actually a programming principle, stating that you should never add features under the assumption that someone might need it someday. Chances are that users either won&#8217;t need it, won&#8217;t want it, or will end up preferring something significantly different than what you provided. But I think this principle can be simplified down to &#8220;provide the minimum set of options and features to allow users to complete the task&#8221;. Simpler products are easier to learn, easier to master, and easier to create and test. The only extra work is in designing it properly.</p>

<p>With this in mind, let&#8217;s turn towards Ubuntu. I&#8217;m hardly a Linux novice, having used Gentoo, Fedora, Ubuntu, Debian, Mint, openSuse, and others before eventually converting to Mac OSX. I had to upgrade my spare Ubuntu box this week from 12.04 all the way to 13.04, and found a few gripes.</p>

<p>First of all, there&#8217;s the Amazon search feature they added sometime in the 11.X releases. It slows the search box down, which is the main way that applications are opened, and clutters up the results. Besides being a transparent money grab, I have a hard time imagining someone trying to open up their music client and suddenly deciding that they need to buy some cheese crackers <em>right now</em>. It all seems like quite a bit of distraction in order to enable a few users that want to order from Amazon without having to fire up Chrome first.</p>

<p>But the part that really angered me was when I tried to turn this &#8220;feature&#8221; off. I couldn&#8217;t find any settings within the dock itself (right clicking does nothing, it seems), and I couldn&#8217;t find any reference to it in the system settings panel either. A quick trip to Google, which I feel shouldn&#8217;t have been necessary, told me that I could turn this search off in the Privacy settings, for some reason. As annoying as this was, all would be well if the upgrade to 12.10 didn&#8217;t <strong>turn it back on again</strong>. Why would you do that to me, Ubuntu? I clearly stated that I had no interest in this mis-feature by hunting it down and disabling it, what purpose does re-enabling it have other than grab a bit more money from Amazon and anger me?</p>

<p>It&#8217;s these little mis-steps and more that make or break the user experience of a product. I&#8217;m fairly tech savvy, and am comfortable digging through StackExchange and various forums to find some solutions to my problems, but that&#8217;s not the way that the average customer works. For those who aren&#8217;t comfortable looking up answers or editing configuration files, these little details will quickly scare them away to an operating system that&#8217;s less surprising and simpler. And these are the users that Canonical must attract if they&#8217;re hoping to turn Ubuntu into a mainstream Operating System.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing Butler.el]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2013/05/03/introducing-butler-dot-el/"/>
    <updated>2013-05-03T20:00:00-06:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2013/05/03/introducing-butler-dot-el</id>
    <content type="html"><![CDATA[<p>I&#8217;m a big fan of reducing barriers to increase adoption and compliance. One of the largest examples for me in the past few months was when I tried out Eclipse for Python Development. The most important plugins for me (other than Python and Git) were the Jenkins and Jira plugins. Quick access to my tasks and instantaneous in-editor feedback about job status increased the likelihood that I would respond to failed builds or fill out tickets correctly.</p>

<p>I eventually decided that Eclipse was overkill for Python development, and way too heavy for a Macbook Air. But in my switch back to Emacs I particularly missed my Jira and Jenkins plugins. This is why I&#8217;m writing to announce the 0.1.0 release of <a href="https://github.com/AshtonKem/Butler">Butler</a>. Butler allows for you to view the jobs on your Jenkins servers, and trigger new jobs without switching out of Emacs.</p>

<p>At this point Butler&#8217;s feature set is modest: view, refresh, and trigger. These are just the groundwork functions for a larger feature set in the coming weeks, including console output, visual indication of running jobs, watching jobs, build queue, etc. I have high hopes that in a few months this plugin will be as mature as its eclipse counterpart.</p>

<p>If you have any bugs or feature requests, please add them to the Github issue tracker.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A New Addiction]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2013/04/30/a-new-addiction/"/>
    <updated>2013-04-30T19:53:00-06:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2013/04/30/a-new-addiction</id>
    <content type="html"><![CDATA[<p>Well, I have officially started collecting watches. My first decent purchase was a few months ago, but I&#8217;m counting it as a collection now because I have more pieces than is functionally required, which arguably is 1 in the cell phone era.</p>

<p>Why collect watches? Well, first of all they&#8217;re modern Mens jewelry. Mens fashion has changed remarkably little in the century, especially compared to Womens&#8217;. So with suits that may stay &#8220;in style&#8221; for 2-6 years depending on the cut, men only have a few places to go to express their style: shoes, watches, ties, and cuff links.</p>

<p>Further still, very few men under the age of 25 (my group at the moment) wear suits. I usually wear a button up or t-shirt to work, and rarely wear any pants more fancy than jeans. This leaves me shoes and watches. This of course also limits my shoe choices a bit, as does the weather in Chicago and my commuting method of choice (bike).</p>

<p>So, that leaves the lonely watch as my main fashion item. What I particularly love about watches is their intricacy, especially mechanical ones. What I love even more about them is how functional yet counter-functional they can be. Watches do one thing quite well: deal with the passing of time. But at the same time, they&#8217;re hardly required in the era of LED signs, car clocks, and cell phones. Furthermore, many have far more complications (features beyond basic date &amp; time) than most people will use. How many people actually time things with their chronographs? How many divers watches rated to 200m go futher underwater than 8 feet? Not many.</p>

<p>At this point, I have two pieces in my collection which I will photograph and post later:</p>

<ul>
<li>A quartz Fossil chronograph, with leather band.</li>
<li>An Invicta Pro Diver Automatic, in stainless steel.</li>
</ul>


<p>I enjoy both quite a bit. The Fossil has a surprising amount of sentimental value for me already, as it was my Valentine&#8217;s day gift this year. But I&#8217;m also growing to love the Invicta, it feels more serious with its weight, and the hands glow to a degree I&#8217;d never seen before.</p>

<p>Next step? Time to start hitting up estate sales and thrift shops in look of a hidden treasure.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Binding vs. Assignment ]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2013/04/30/binding-vs-assignment/"/>
    <updated>2013-04-30T07:23:00-06:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2013/04/30/binding-vs-assignment</id>
    <content type="html"><![CDATA[<p>A coworker of mine was recently running into problems with the following snippet of Python code, and turned to another functionally oriented developer and myself for help.</p>

<figure class='code'><figcaption><span>Odd Functions</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">funs</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;a&quot;</span> <span class="s">&quot;b&quot;</span><span class="p">]:</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">internal_function</span><span class="p">():</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">i</span>
</span><span class='line'>    <span class="n">funs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">internal_function</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="n">funs</span><span class="p">[</span><span class="mi">0</span><span class="p">]()</span>
</span><span class='line'><span class="k">print</span> <span class="n">funs</span><span class="p">[</span><span class="mi">1</span><span class="p">]()</span>
</span></code></pre></td></tr></table></div></figure>


<p>At first glance, one would expect this to print &#8220;a&#8221; then &#8220;b&#8221;. But much to my surprise (and my coworkers frustration), it was returning &#8220;b&#8221; both times.</p>

<p>My first instinct was that Python was closing properly, but was messing up the namespacing. So I asked him to use lambdas instead, creating this:</p>

<figure class='code'><figcaption><span>Lambdas</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">funs</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">]:</span>
</span><span class='line'>    <span class="n">funs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="n">funs</span><span class="p">[</span><span class="mi">0</span><span class="p">]()</span>
</span><span class='line'><span class="k">print</span> <span class="n">funs</span><span class="p">[</span><span class="mi">1</span><span class="p">]()</span>
</span></code></pre></td></tr></table></div></figure>


<p>Same result! So by this point we know that its not namespacing that is causing the problems, as you can&#8217;t accidentally assign two lambdas the same name. So I began to suspect that the use of &#8220;i&#8221; was the issue. Perhaps we&#8217;re closing around i, which is a mutable variable, and Python can&#8217;t anticipate that we want a copy instead of the actual reference. Since i is mutable, both closures are having what i means changed from underneath them after closure creation time. (Coincidentally, Python 2.7.3 keeps i around even after the loop is completed, which I think is odd).</p>

<p>So the solution here would be to use a temporary variable. Any variable first created inside a loop should theoretically only have a lifespan of one iteration through the loop. So let&#8217;s try the following:</p>

<figure class='code'><figcaption><span>Temporary Variables</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">funs</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">]:</span>
</span><span class='line'>    <span class="n">temp</span> <span class="o">=</span> <span class="n">i</span>
</span><span class='line'>    <span class="n">funs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">temp</span><span class="p">)</span>
</span><span class='line'><span class="k">print</span> <span class="n">funs</span><span class="p">[</span><span class="mi">0</span><span class="p">]()</span>
</span><span class='line'><span class="k">print</span> <span class="n">funs</span><span class="p">[</span><span class="mi">1</span><span class="p">]()</span>
</span></code></pre></td></tr></table></div></figure>


<p>Same result, again! So clearly python is mishandling variables by a large amount. So what&#8217;s going on here? My fellow functional coworker was finally able to explain: the real problem here is that Python conflates binding and assignment. Binding is used to create a new variable <em>within the current context</em>, while assignment can only change the value of a given variable within the narrowest bound scope.</p>

<p>Why is this an issue? Well, Python uses the same symbol &#8220;=&#8221;, to specify binding and assignment, while most other languages use two syntactic rules. For example Go apparently uses &#8220;:=&#8221; to bind, and &#8220;=&#8221; to assign. Java uses type declarations to denote bindings, and Clojure/Haskell more or less only have bindings underneath. Unfortunately there&#8217;s an upper limit to how intelligent an imperative compiler can get, especially in interpreted languages where the compiler must be fairly quick. So Python doesn&#8217;t do the leg work to realize that temp is only used inside the loop, and binds it only once <em>outside the loop</em>. The side effect of this is that anyone who closes over any local variable inside the loop will be surprised when it is mutated by further iterations, and said variables will be left laying around <strong>after the loop is done</strong>.</p>

<p>So how do we get out of this? One obvious option is to pick a language that understands the difference. Short of that, use a separate function to force Python&#8217;s hand.</p>

<figure class='code'><figcaption><span>Ugly Fix</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">create_lambda</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">lambda</span> <span class="p">:</span> <span class="n">x</span>
</span><span class='line'>
</span><span class='line'><span class="n">funs</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">]:</span>
</span><span class='line'>    <span class="n">funs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">create_lambda</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="n">funs</span><span class="p">[</span><span class="mi">0</span><span class="p">]()</span>
</span><span class='line'><span class="n">funs</span><span class="p">[</span><span class="mi">1</span><span class="p">]()</span>
</span></code></pre></td></tr></table></div></figure>


<p>Which unfortunately is pretty ugly. Other languages will get you out of this bind though. Clojure has no concept of assigning variables, only binding. So the only way to create mutable state in Clojure is through successive binds, or via the special Software Transactional Memory functions, which are specially designed for concurrency.</p>

<figure class='code'><figcaption><span>Nice and Clean</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">funs</span>
</span><span class='line'>     <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">i</span> <span class="p">[</span><span class="s">&quot;a&quot;</span> <span class="s">&quot;b&quot;</span><span class="p">]]</span>
</span><span class='line'>         <span class="p">(</span><span class="k">fn </span><span class="p">[]</span>
</span><span class='line'>             <span class="nv">i</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nb">println </span><span class="p">((</span><span class="nb">first </span><span class="nv">funs</span><span class="p">)))</span>
</span><span class='line'><span class="p">(</span><span class="nb">println </span><span class="p">((</span><span class="nb">second </span><span class="nv">funs</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>And according to my Go enthused coworker, this also works:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='go'><span class='line'><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">i</span>
</span><span class='line'>
</span><span class='line'>        <span class="nx">funs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kd">func</span> <span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">tmp</span>
</span><span class='line'>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">funs</span><span class="p">[</span><span class="mi">0</span><span class="p">]())</span>
</span><span class='line'>    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">funs</span><span class="p">[</span><span class="mi">1</span><span class="p">]())</span>
</span><span class='line'>    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">funs</span><span class="p">[</span><span class="mi">2</span><span class="p">]())</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you are currently working on a Python project, or are a Python enthusiast, the only hope is to be careful, and hope that Python 3&#8217;s compiler might be more intelligent.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Size Matters]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2013/04/23/size-matters/"/>
    <updated>2013-04-23T21:54:00-06:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2013/04/23/size-matters</id>
    <content type="html"><![CDATA[<p>About 6 months ago I started to look for a new language for hobby projects. I wanted something practical, yet fun. I managed to limit the criteria down to:</p>

<ul>
<li>Functional</li>
<li>Good community</li>
<li>Growing acceptance</li>
</ul>


<p>This automatically eliminates a lot common languages, like Python, Ruby, and Java. After my Common Lisp job, I knew that a sane compilation system/target were an absolute must, so I looked at Scala first. On the surface Scala seemed a real winner: growing fan base, increasing commercial adoption, functional, and targeting the JVM. But while trying out Scala I realized that I had missed a huge criteria: language size.</p>

<p>There&#8217;s only so much information that a programmer can keep in their mind at a time. Every programmer needs to split their internal memory in at least 4 different ways, if not more. There are language details to remember, library or API interfaces to recall, domain knowledge to retain, and possibly coordination or social issues to be concerned about. Once this internal memory is exceeded details end up being forgotten, and recalling forgotten information involves an expensive round trip to documentation, code, or the internet.</p>

<p>There&#8217;s no escaping the need to recall language details, at least until someone invents a syntax free programming languages; similarly it&#8217;s near impossible to write an application of any size without relying on libraries or APIs. Domain knowledge is often expensive to acquire and beneficial to have. And social issues cannot be resolved by programming language choice alone.</p>

<p>So the real question is, what are you going to skimp on? Are you going to pay the price of memory &#8220;cache misses&#8221;? Are you going to forget portions of your language, or certain libraries? Or are you going to segregate domain knowledge among the team so that everyone knows their bit only?</p>

<p>The real world answer is probably a bit of each. But I contend that reduction of language features in memory is the least damaging of all the outcomes. I doubt it&#8217;s controversial to say that domain knowledge should be shared widely among developers, and should be as much in memory as possible; programmers who understand what they&#8217;re programming for tend to program better on average. Similarly it&#8217;s hard to eliminate a decently written library: that functionality has to come from somewhere, and it&#8217;ll either be an external library, an internal one, or duplicated code.</p>

<p>But language reduction is an interesting idea. Programmers long ago got away with previous few features, yet managed some amazing things. Don&#8217;t believe me? Consider how small the Scheme spec is compared to say, Java. It reduces the need for fancy and hard to learn IDEs, allows the programmer to get more done between looking up function or class definitions, and increases the speed with which an engineer can fully understand a piece of code.</p>

<p>It was actually this feature that finally drove me away from Scala to Clojure. After a few hours of Scala work I was turned off by the size of the language, and got tired of saying &#8220;Why did it do that?&#8221; Clojure on the other hand is relatively small, only a dozen &#8220;special forms&#8221; which have to be hard coded into the language, and then a 3-4 dozen core functions. This means that I can both keep the entire language in memory, and retain a large amount of library and domain knowledge to get work done.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2013/04/22/octopress/"/>
    <updated>2013-04-22T22:16:00-06:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2013/04/22/octopress</id>
    <content type="html"><![CDATA[<p>I&#8217;m currently in the process of changing my website over from Wordpress.com to Octopress on Github pages. There are two things driving me from Wordpress.com: control and price.</p>

<p>Wordpress is fine if you are either a big PHP afficianado, or are afraid of web programming in general. It&#8217;s quite easy to install themes and plugins without any knowledge of what this means. However, this only is true if you&#8217;re self-hosting Wordpress.org (the project) and not using Wordpress.com (the commercial website using Wordpress.org). On Wordpress.org you&#8217;re stuck using a limited number of (mostly for pay) themes and plugins, and are restricted from inserting HTML, JS, or CSS into your website.</p>

<p>So if you want Google Analytics, you&#8217;ll need to use a third party CDN who can inject the Google Analytics JS into the DOM. No thanks. If you want any social networking integration, you better hope that Wordpress.com supports it (sorry, app.net users!). And if you want pictures or other media, you&#8217;ll have to manually control the links to a third party system or hope that you don&#8217;t exceed the cheap data storage tier on wordpress.com.</p>

<p>So what&#8217;s so great about Octopress?</p>

<ol>
<li>Free or cheap hosting wherever.</li>
<li>Easy dev preview.</li>
<li>Version controlling.</li>
</ol>


<p>Octopress uses Jekyll, which makes it really easy to separate content from presentation, and produces purely static webpages that can be tossed onto any webhost. It also has great integration for thid party systems, and adding your own is only a hop, skip, and a bit of JS away. Local development is super straightforward with the <code>rake generate</code> and <code>rake preview</code> commands, which produce static HTML and a testing webserver, respectively. And everything is stored in Git, so upgrading is only a matter of merging (!), and you can host on Github by pushing to the correct repo  (or use <code>rake deploy</code>). And since your side is code, you don&#8217;t have to count on flimsy undo support, merely revert commits as needed to go back in history.</p>

<p>So far the only hiccup is moving all of the comments over from Worpress to Disqus. All of the docs on this I&#8217;ve seen are out of date, I&#8217;ll report if I get this working.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Doesn’t Deserve Half the Shit we Give It]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2013/01/22/java-doesnt-deserve-half-the-shit-we-give-it/"/>
    <updated>2013-01-22T21:22:00-07:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2013/01/22/java-doesnt-deserve-half-the-shit-we-give-it</id>
    <content type="html"><![CDATA[<p>It’s very popular among programmers to diss Java on Reddit and Hacker News. But Java really isn’t that bad of a language, and I really think there are other reasons why people hate it.</p>

<p>While we like to pretend that programming language choice is purely about practicality, there is a very large social aspect to it. Nobody wants to admit to liking Cobol or VBA, and being at the forefront of a new, exciting language can bring a type of prestige in programming circles. Thus to some degree, our choice of programming language reflects on how we wish to see ourselves. Haskell programmers think of themselves as highly skilled mathematicians, python users think of themselves as massively productive, etc.</p>

<p>Personally, I think the easiest way to sum up the design decisions behind Java is thusly: You have a large number of average programmers, how can you get them to design large and complicated systems reliably. This is not the most exciting idea in the world, but it’s thoroughly realistic. Your average programmer is, well, average. While this may be reason enough to not bother with Java in your hobby projects, I don’t really see this as a reason to heap scorn upon it. It may not be exciting, but Java really isn’t that bad.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Right vs. Useful]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2013/01/03/right-vs-useful/"/>
    <updated>2013-01-03T21:21:00-07:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2013/01/03/right-vs-useful</id>
    <content type="html"><![CDATA[<p>I spend a fairly decent amount of my time thinking about how my mindset and world view affects my decisions and actions. In the past few months I’ve found that how I evaluate these mindsets has begun to change; I used to be mostly concerned with whether or not a mindset was correct, but now I’ve started to think about whether or not it’s useful.</p>

<p>Determining whether or not a mindset is correct is rather tricky philosophical ground, as it requires some sort of platonic “reality” to compare it against. But for the sake of argument, let us say that a “correct” mindset matches the most unbiased observations of the world we can make, or logically follows from a set of axioms that are relatively well accepted. Good examples of correct mindsets are “Not lying on my taxes reduces the chance of getting in trouble”, and “driving according to traffic laws means I won’t get a ticket”.</p>

<p>Useful mindsets are even easier. A useful mindset is one that produces more beneficial outcomes for the user, where beneficial is also defined by the user. The best examples of useful mindsets are also correct, those who don’t speed don’t get speeding tickets, etc.</p>

<p>Where things get interesting is where useful and right don’t necessarily agree, or when it’s not currently possible to know what is correct. My particular favorite is the question of free will: It’s not currently known whether or not humans make actual decisions, or if we are merely a product of a deterministic universe.</p>

<p>Whether or not we have free will is probably beyond our current philosophical and scientific knowledge, and it’s certainly beyond mine. But we can analyze what our belief in free will does to our ability. The inputs to this scenario can be put on a 2×2 grid, 2 options for our belief (free will or not), 2 for reality (free will or deterministic), producing 4 options. If we choose to believe and free will, and free will exists we gain our own future. If we choose to believe in free will, and it doesn’t exist, we were predestined to believe as such, ditto if we don’t believe and free will doesn’t exist. But the really painful point is when we choose to not believe in free will and it exists, we end up surrendering our initiative and free well, blaming everything on fate. The obvious choice is to believe in free will, and hope for the best.</p>

<p>The more astute among you will recognize this as Pascal’s wager (which is also a form of the more general Prisoners Dilemna). Personally Pascal’s wager has never swayed my belief, as I’ve found reasons to disagree with its setup (the wager only works if you assume free will, and a vengeful Abrahamic God. If you disagree with this portrayal of a higher being, Pascal’s wager doesn’t work out the same).</p>

<p>So next time you find yourself thinking about your worldview, try using usefulness as another yardstick to compare your beliefs against.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learn What You Don't Like]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2012/12/10/learn-what-you-dont-like/"/>
    <updated>2012-12-10T21:19:00-07:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2012/12/10/learn-what-you-dont-like</id>
    <content type="html"><![CDATA[<p>There’s really nothing worse than someone who has lived their life surrounded by people who agree with them fully. People who live this way have confidence that precedes their knowledge, and will treat contradictory knowledge as an attack on their in-group and world view.</p>

<p>While the above mentioned effect is generally most common in religion and politics, it crops up sometimes in engineering in the so called “holy wars”. Linux vs. Mac vs. Windows, Emacs vs. Vim, etc. The more similar the items in question, the more intense the debate.</p>

<p>This is why I think it’s pretty important to try out technologies that you’d formally written off, and re-evaluate your decisions. I’ve been an Emacs user for about 5 years now, and I’d written off learning Vim for anything other than emergency config-editing on a remote server. But at the behest of my colleagues, I tried Vim for a few weeks recently, and I’ve come to a surprising conclusion: I don’t like Vim. But rather than disliking Vim because I’d already invested in Emacs, I’ve learned exactly what I need first and foremost in an editor, and an understanding of the compromises I’m making in order to use Emacs. Basically it toned me down from being a mild Emacs zealot to an Emacs user.</p>

<p>What exactly made me go back? First and foremost, I strongly prefer the way that Emacs uses buffers. The fact that I don’t have to worry about closing a buffer closing Emacs, and the fact that I can purposefully leave buffers unsaved is nice. I also like having multiple shells open to run various programs needed for development purposes, and I found the Vim solution, ConqueTerm, to be insufficient for my needs.</p>

<p>What do I miss from Vim though? While I’m not sold on modality (it’s another thing to track), Vim’s key combinations are truly superior to Emacs’ offering, especially when it comes to repeating and chaining actions. Also, while Vim’s shells are less intuitive than Emacs’, they tend to survive heavy program output better (30+ megs of terminal output to the shell tends to overload Emacs’ poor head). But the most important thing is that I learned what I value most in an editor, so I  will know in the future whether or not a new editor will be right for me.</p>

<p>Now that I look back, I see similar Emacs vs. Vim moments in the past few years. One of the more recent moments was retrying Python, which I had written off in my early college years due to a bad experience. In retrying Python, I discovered that it had a few things that I valued highly in a language, and ended up leaving Ruby for it. And I’d never have made the switch if I hadn’t tried out something I didn’t like.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hands and Feet]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2012/12/01/hands-and-feet/"/>
    <updated>2012-12-01T21:16:00-07:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2012/12/01/hands-and-feet</id>
    <content type="html"><![CDATA[<p>When I was a teenager I worked at a large amusement park in the games department, which I guess technically means I was a carnie. One of the more interesting games I worked at was the rope ladder; in order to win the game contestants had to climb up a rope ladder set at a 45 degree angle and attached to swivel points at the bottom. Unsurprisingly I learned to climb it easily (free tries and boredom does wonders for learning), but I witnessed very few winners.</p>

<p>One of the more important lessons I learned was about how to not think about specific tasks. In order to climb the ladder, you need to move opposite limbs: step forward with your right hand and left foot at the same time, etc. This spreads your weight out, and ensures that any movement you make is relatively counter-balanced, reducing the maximum amount you’ll find yourself unbalanced at a given moment. What was particularly interesting to me was the transition from not-making it, to making it. When I first started, I had to concentrate on my hands and feet, and fell constantly. Only once I learned to move my hands and feet without conscious thought, and thus free up my mind to worry about my balance, did I successfully climb the ladder.</p>

<p>This has fairly important implications to my daily work: namely that I cannot concentrate on doing good engineering work without making everything else a subconscious action. Every single non-work related activity breaks concentration for a short period of time, and potentially might take me out of the elusive “zone”. I’ve discovered that If I’m concentrating on your editor, I’m not going to code effectively (if at all). Therefore, It’s absolutely important that every single editor and environment change that you make is judged by balancing how much time/energy it takes to learn and use against its effect. The most powerful Git extension in the world for your editor will do you no good if it takes 2 minutes to commit each time: it would take less time and mindshare to simply type or alias it out on the shell.</p>

<p>For example I use the <a href="http://philjackson.github.com/magit/">Magit</a> extension for Emacs to avoid having to go to a terminal to use git; the gains for moderately complicated tasks such as stash manipulation, reverting files, and partially staging a file are truly tremendous. Similarly I use a pylint &amp; nosetests extension for Emacs to avoid having to remember the (quite long) commands it takes to run each command correctly. This also has the tremendous advantage of not linting or testing code that’s outside of my purview, thus running faster and cluttering my mind less with irrelevant results.</p>

<p>The other important take away is to not overdue it. The point of any given addition to your editing environment is to improve the quality and quantity of your engineering output. So if your editor bothers you every 5 minutes with CI notifications that aren’t related to any of your commits, you aren’t really gaining anything. This is why I ended up turning off the Pyflakes/Flymake extension to Emacs: it improved my coding a bit at the time (although most of the time it highlighted code that I hadn’t finished typing yet), but the additional .flymake files it left laying around tripled the amount of time it took for me to work with Git. It simply wasn’t worth the trouble in the long run.</p>

<p>The easiest way to tell whether or not something is worth it is to read the manual and give it a try. Some tools take a while to learn, like Magit, and others only take some time in the setup, like Flymake. Once you’ve exited the learning stage, you should think heavily about whether or not you’re concentrating on the tool instead of your work, and whether or not this has affected the quality or quantity of your output. Remember, there’s no shame in uninstalling a tool if it really doesn’t make your life easier.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reaction to Kill Your Heroes (and Comments)]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2012/11/29/reaction-to-kill-your-heroes-and-comments/"/>
    <updated>2012-11-29T00:00:00-07:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2012/11/29/reaction-to-kill-your-heroes-and-comments</id>
    <content type="html"><![CDATA[<p>Will Larsen had a nice post about what he calls <a href="http://lethain.com/doing-it-harder-and-hero-programming/">Hero Programmers</a>. Put simply, his theory is that some projects end up in a state where they count on massive effort by a select few heroes on the team. The problem is that this upsets those who aren’t heroes, burns out the heroes, and still won’t save an ailing project.</p>

<p>What was particularly interesting to me was some of the responses on Reddit. In particular one quote from “name_was_taken” stands out to me: “Fire the developers who are useless.”</p>

<p>There is a big assumption on both sides of this discussion that should be cleared. name_was_taken is assuming that the other devs aren’t carrying their own weight, Will Larsen is assuming that the environment is setup to discourage them from doing so.</p>

<p>There are obvious situations where you should fire a developer: misbehavior at work, damaging to team morale, poor performance, low reliability, etc. This is not about the obvious case. This is about when you have decent devs all around, but the distribution of effectiveness is massively unequal.</p>

<p>I think name_was_taken’s attitude comes from an assumption that there’ll be a “Star Programmer” available for this company to hire, that way they can have nothing but heroes. I don’t think that’s possible, and I think that’s a dangerous ideology to run a business on. The simple fact of it is that most programmers are average, and only a small handful are truly stellar. Therefore, any good business should attempt to hire the best, and plan for average.</p>

<p>The truly dangerous thing about the hero mentality is what it does to performance overall. Projects that require heroic attempts at fixing them often exclude team efforts. If one person is running around, massively refactoring everything, in an attempt to hold everything together, there is little to no chance that any other developer will be able to get any work done. They’ll have to keep up with a quickly changing system (that they have no input to), and make sure they don’t step on the heroes toes while working.</p>

<p>So the solution is to get out of this mode. Hero mode will burn out your heroes, and make it almost impossible to use the majority of your dev team. Even if you cull the worst members of your team, you will not be able to reliably hire more heroes in the best of circumstances, and most star programmers can smell and avoid an out of control project a mile away.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Myth of the Lone Hacker]]></title>
    <link href="http://www.ashtonkemerling.com/blog/2012/11/22/the-myth-of-the-lone-hacker/"/>
    <updated>2012-11-22T20:07:00-07:00</updated>
    <id>http://www.ashtonkemerling.com/blog/2012/11/22/the-myth-of-the-lone-hacker</id>
    <content type="html"><![CDATA[<p>Most programmers start off their career relatively idealistic, and often marvel at the power of little used programming languages. For me, this language was Common Lisp, which I got to work with professionally. At first I believed that Lisp still had the power to revolutionize programming, but after a few years of work I realized exactly why Lisp ended up in the position it is now: community. Every programming community has a few core beliefs, both explicit and implicit, that shape the language, the libraries, and its users. The Haskell community believes that errors should be caught by the compiler as often as possible, and Ruby believes in the principle of least astonishment. The Lisp community suffers from a belief that I call the Myth of the Lone Hacker.</p>

<p>Most simply put, the myth of the lone hacker is a strong faith in the power of individual hackers to affect large scale change. Most programmers hold this belief to some degree, but the more closely held the belief, the more dangerous to the community it becomes.</p>

<p>Why is it dangerous? Because when you believe that individual hackers are the only means of affecting change, it de-incentivizes work on utilities and libraries that are necessary for group engineering efforts. Lone hackers don’t have anything to integrate, so there’s no point in working on CI utilities. Lone hackers get their work done the first time, so who needs unit tests? There’s only one machine to work on, so who needs packaging and repeatable builds? Lone hackers also know how they prefer to write their own libraries, and clearly everyone else would be better off doing as well!</p>

<p>This is largely what has happened to Lisp since the beginning of the AI Winter. Libraries tend to be single purpose “trivial” implementations that met the exact needs of the original author, and are often very difficult to extend or maintain. Documentation tends to be sparse (“read the code!” doesn’t count as documentation), in some cases resulting in a list of functions with no obvious entry points. And any attempt to learn from or copy popular languages such as Ruby, Python, and Java is dismissed as “reeking of the cubicle”.</p>

<p>Of course, what many people fail to realize is that the myth is fairly incorrect. While there may be some rare cases, the vast majority of the time brilliant hackers only start a movement. For every Donald Knuth who writes and maintains something like Tex, there are 10 or more Guido van Rossum and Linus Torvalds; highly motivated individuals who started a movement which eventually involved large numbers of engineers. Guido and Linus may be founders and public front figures of their projects, but without the effort of countless other engineers, part and full time, their projects would have never made it off the ground.</p>

<p>This is of course, nothing new. While individuals tend to have moments of insights, modern software projects are simply too large for a single individual to engineer it within a reasonable period of time. To dismiss team work as “cubicle work” is to simply dismiss the majority of potential software projects due to their scale.</p>

<p>There is some hope yet for Lisp, with tools such as QuickLisp coming along. Unfortunately I personally feel that the language has a lot of technical and social debt that’ll be difficult to overcome. What Lisp really needs to do is attract younger engineers who will eventually mature and produce good libraries for the community, and they need to do that without spoiling them with the myth in the mean time.</p>
]]></content>
  </entry>
  
</feed>
